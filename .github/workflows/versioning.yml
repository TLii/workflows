name: Determine versioning

on:
  workflow_call:
    inputs:
      last_build_head:
        type: string
        description: 'Commit id on the last build'
        required: true
      current_version:
        type: string
        description: 'Current version before a possible bump'
        required: true
      use_build_numbers:
        type: string
        description: 'Add build number to semver string'
        required: false
        default: 'true'

jobs:

  build:
    runs-on: ubuntu-latest

    outputs:
      version_type: ${{ steps.get_version.outputs.version_type }}
      version: ${{ steps.bump_version.outputs.next-version }}
      version_value: ${{ steps.get_version.outputs.version_type_value }}
      build_needed: ${{ steps.get_version.outputs.build_needed }}

    steps:

    - name: Decide on build and versioning
      id: get_version
      run: |
        last_head=${{ inputs.last_build_head}} # The commit id of the last build

        if [[ -n $last_head ]]; then
          # If last build was not recorded, assume a rebuild with minimal versioning.
          echo "No recorded last build head, so just doing a rebuild without version bumps."
          echo "version_type=none" >> "$GITHUB_OUTPUT";
          echo "build_needed=true" >> "$GITHUB_OUTPUT"

        else
          # See if there are any file changes since last build that warrant a new build

          # Default to no change
          source_changed=false

          # Loop through all files changed since last build
          for file in $(git diff --name-only "$last_head" HEAD); do

              # If file is only related to workflows or ci, then no need for a new build.
              # In other cases, a new build is needed.

              if [[ $file != .ci/* ]] && [[ $file != .github/* ]]; then

                echo  "A change in source detected."
                source_changed=true

                # As an optimization, we can stop the loop if we detect the first relevant change
                # in the source.
                # This is because we only need to know if a change has occurred, not how many.
                break

              fi
          done

          # If no change in source, no need for a new build, and this job can be skipped.

          if [[ $source_changed == false ]]; then
            echo "No build necessary"
            echo "build_needed=false" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "A build is needed."
            echo "build_needed=true" >> "$GITHUB_OUTPUT"
          fi
        fi

    - name: Determine bump type
      id: bump_type
      if: >-
        steps.get_version.outputs.version_type != 'none' &&
        steps.get_version.outputs.build_needed == 'true'
      run: |

        # Determine the level of change for semver bump.
        # Possible options are [ major | feature | bug | alpha | beta | pre | rc | build ]
        # Numeric values are   [  8    |   7     |  6  |  2    |  3   | 4   | 5  |    1 ]

        # Determine needed semver bump by looking at the commit headers.
        # If there are multiple commits, the highest level of change is used.
        # The logic is as follows:
        # - If there are breaking changes, bump the major version
        # - If there are new features, bump the feature version
        # - If there are bug fixes, bump the minor version
        # - Control alpha, beta, pre, rc, and build versions by suffixing the commit header with -[a|alpha|b|beta|p|pre|r|rc], eg. 'fix-alpha' or 'feat-rc'.

        # Conventional commits:
        # build: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)
        # ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)
        # docs: Documentation only changes
        # feat: A new feature
        # fix: A bug fix
        # perf: A code change that improves performance
        # refactor: A code change that neither fixes a bug nor adds a feature
        # style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
        # test: Adding missing tests or correcting existing tests

          highest=0

          for i in $(git rev-list --format=%B --oneline --all | grep -e '^[a-zA-Z0-9]* [a-zA-Z!-]*[!]\?[-]\?[a-zA-Z]*(' | sed 's|^[a-zA-Z0-9]* \([a-zA-Z!-]*\)(.*).*|\1|'); do
            [[ ($i == *-alpha* || $i == *-a*) && $highest -lt 2 ]] && highest=2 && continue;
            [[ ($i == *-beta* || $i == *-b*) && $highest -lt 3 ]] && highest=3 && continue;
            [[ ($i == *-pre* || $i == *-p*) && $highest -lt 4 ]] && highest=4 && continue;
            [[ ($i == *-rc* || $i == *-r*) && $highest -lt 5 ]] && highest=5 && continue;
            [[ $i == *\! && $highest -lt 8 ]] && highest=8 && continue;
            [[ $i == 'feat' && $highest -lt 7 ]] && highest=7 && continue;
            [[ $i == 'fix' && $highest -lt 6 ]] && highest=6 && continue;
            [[ $i == 'perf' && $highest -lt 2 ]] && highest=2 && continue;
            [[ $i == 'refactor' && $highest -lt 2 ]] && highest=2 && continue;
            [[ $i == 'test' && $highest -lt 2 ]] && highest=2 && continue;
            [[ $i == 'build' && $highest -lt 1 ]] && highest=1 && continue;
            [[ $i == 'style' && $highest -lt 1 ]] && highest=1 && continue;
            [[ $i == 'docs' ]] && highest=0 && continue;
            [[ $i == 'ci' ]] && highest=0 && continue;
          done
          echo "Highest value was $highest."
          echo "version_type_value=$highest" >> "$GITHUB_OUTPUT";
          version_type=none;
          case $highest in
            8)
              version_type=major
              ;;
            7)
              version_type=feature
              ;;
            6)
              version_type=bug
              ;;
            5)
              version_type=rc
              ;;
            4)
              version_type=pre
              ;;
            3)
              version_type=beta
              ;;
            2)
              version_type=alpha
              ;;
            1)
              version_type=build
              ;;
            *)
              version_type=none
              ;;
          esac
        fi
        use_build_numbers=${{ inputs.use_build_numbers }}
        if [[ ! $use_build_numbers ]] && [[ $version_type=build ]]; then
          echo "version_type=none" >> "$GITHUB_OUTPUT";
        else
          echo "version_type=$version_type" >> "$GITHUB_OUTPUT";
        fi

    - name: Update semantic version
      id: bump_version
      if: >-
        steps.get_version.outputs.version_type != 'none' &&
        steps.get_version.outputs.build_needed == 'true'
      uses: TLii/increment-semantic-version-with-build-numbers@1.0.0
      with:
        current-version: ${{ inputs.current_version }}
        version-fragment: ${{ steps.bump_type.outputs.version_type }}
        include-build-number: ${{ inputs.use_build_numbers }}

    - name: Don't update semantic version
      id: return
      run: |
        new_version=${{ steps.bump_version.outputs.next-version }}

        if [[ -n $new_version ]]; then
          echo "next-version=$new_version" >> "$GITHUB_OUTPUT"
        else
          echo "next-version=${{ inputs.current_version }}" >> "$GITHUB_OUTPUT"
        fi